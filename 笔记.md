信号槽的调用要比普通的函数调用慢大约一个数量级

信号槽：所谓信号槽，实际就是观察者模式。

当某个事件发生之后，比如，按钮检测到自己被点击了一下，它就会发出一个信号（signal）。这种发出是没有目的的，类似广播。如果有对象对这个信号感兴趣，它就会使用连接（connect）函数，意思是，用自己的一个函数（成为槽（slot））来处理这个信号。也就是说，当信号发出时，被连接的槽函数会自动被回调。这就类似观察者模式：当发生了感兴趣的事件，某一个操作就会被自动触发。*（这里提一句，Qt 的信号槽使用了额外的处理来实现，并不是 GoF 经典的观察者模式的实现方式。）*

Essentials Modules 基础模块 Add-on Modules 扩展模块

Qt中的moc（Meta Object Compiler，元对象编译器）

先对 Qt 源代码进行一次预处理（ *注意，这个预处理与标准 C++ 的预处理有所不同。Qt 的 moc 预处理发生在标准 C++ 预处理器工作之前，并且 Qt 的 moc 预处理不是递归的。* ）

按照 Qt 官方的说法，模板虽然是内置语言特性，但是其语法实在是复杂，并且由于 GUI 是动态的，利用静态的模板机制有时候很难处理。而自己使用 moc 生成代码更为灵活，虽然效率有些降低（一个信号槽的调用大约相当于四个模板函数调用），不过在现代计算机上，这点性能损耗实在是可以忽略。

在 Qt 中，尽量在构造的时候就指定 parent 对象，并且大胆在堆上创建。如下：

```
    QWidget window;
    QPushButton quit("Quit", &window);
```
